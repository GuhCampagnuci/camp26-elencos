export default defineComponent({
  async run({ steps }) {

    // =========================
    // 0) CONFIG - nome do step do Google Sheets
    // =========================
    // Ajuste aqui se seu step do Sheets tiver outro nome.
    // Exemplo comum: steps.google_sheets.$return_value
    const SHEETS_STEP_NAME = "get_values_in_range";

    const sheetStep = steps[SHEETS_STEP_NAME];
    const rows = sheetStep?.$return_value || [];

    if (!Array.isArray(rows) || rows.length === 0) {
      return {
        teams: [],
        totalTeams: 0,
        totalPlayers: 0,
        warning: "Nenhuma linha recebida do Google Sheets. Verifique o step do Sheets e o range."
      };
    }

    // Remove cabeçalho
    const data = rows.slice(1);

    // =========================
    // 1) Helpers
    // =========================
    const toUpperTrim = (v) => String(v ?? "").trim().toUpperCase();

    // Converte "PE/PD/MD/MC" -> ["PE","PD","MD","MC"]
    const splitPositions = (posRaw) =>
      String(posRaw || "")
        .split("/")
        .map(p => toUpperTrim(p))
        .filter(Boolean);

    // Regra: grupo baseado na PRIMEIRA posição (posição principal)
    const positionGroups = {
      // Goleiro
      GOL: "Goleiros",

      // Defesa
      ZAG: "Defensores",
      LD:  "Defensores",
      LE:  "Defensores",

      // Meio (inclui MEI e VOL)
      MC:  "Meio-campistas",
      MD:  "Meio-campistas",
      ME:  "Meio-campistas",
      MEI: "Meio-campistas",
      VOL: "Meio-campistas",

      // Ataque
      ATA: "Atacantes",
      PD:  "Atacantes",
      PE:  "Atacantes",

      // Se algum dia aparecer:
      CA:  "Atacantes"
    };

    const GROUP_ORDER = ["Goleiros", "Defensores", "Meio-campistas", "Atacantes"];

    const parseOverall = (v) => {
      if (v === null || v === undefined) return null;
      const s = String(v).trim();
      if (s === "") return null;

      // aceita "85", 85, "85.0"
      const n = Number(s.replace(",", "."));
      return Number.isNaN(n) ? null : n;
    };

    // =========================
    // 2) Monta times e jogadores
    // =========================
    const teamsMap = {}; // { "Liverpool": { name, players: [] } }

    for (const row of data) {
      // Esperado: [Time, Jogador, Posições, Overall]
      const teamRaw = row?.[0];
      const nameRaw = row?.[1];
      const posRaw  = row?.[2];
      const ovrRaw  = row?.[3];

      const team = String(teamRaw || "").trim();
      const name = String(nameRaw || "").trim();

      if (!team || !name || !posRaw) continue;

      const positions = splitPositions(posRaw);
      if (!positions.length) continue;

      const primaryPos = positions[0]; // ✅ principal = primeira
      const overall = parseOverall(ovrRaw);

      if (!teamsMap[team]) {
        teamsMap[team] = { name: team, players: [] };
      }

      teamsMap[team].players.push({
        name,
        positions,    // mantém todas (exibição opcional)
        primaryPos,   // ✅ principal
        overall
      });
    }

    // =========================
    // 3) Agrupa por posição principal + ordena por overall desc
    // =========================
    const teams = Object.values(teamsMap).map(team => {

      const groups = {
        "Goleiros": [],
        "Defensores": [],
        "Meio-campistas": [],
        "Atacantes": []
      };

      for (const player of team.players) {
        const group = positionGroups[player.primaryPos] || "Meio-campistas";
        groups[group].push(player);
      }

      // Ordenação: overall desc, null por último, depois nome A-Z
      const sortPlayers = (a, b) => {
        if (a.overall === null && b.overall !== null) return 1;
        if (b.overall === null && a.overall !== null) return -1;
        if (a.overall !== null && b.overall !== null) {
          if (b.overall !== a.overall) return b.overall - a.overall;
        }
        return String(a.name).localeCompare(String(b.name), "pt-BR");
      };

      for (const label of Object.keys(groups)) {
        groups[label].sort(sortPlayers);
      }

      return {
        name: team.name,
        groups: GROUP_ORDER.map(label => ({
          label,
          items: groups[label]
        }))
      };
    });

    // Ordena times A-Z
    teams.sort((a, b) => String(a.name).localeCompare(String(b.name), "pt-BR"));

    // Total de jogadores efetivamente usados (pós-limpeza)
    const totalPlayersUsed = teams.reduce(
      (acc, t) => acc + (t.groups || []).reduce((a2, g) => a2 + (g.items?.length || 0), 0),
      0
    );

    return {
      teams,
      totalTeams: teams.length,
      totalPlayers: totalPlayersUsed
    };
  }
});
